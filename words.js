"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Generated by CoffeeScript 2.7.0
(function () {
  // words.coffee - A Javascript word-string manipulation library, written in Coffeescript.
  // MIT License
  // Copyright (c) 2014 Dennis Raymondo van der Sluis
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  // SOFTWARE.
  "use strict";

  var Chars, Strings, Words, Words_, _, types;

  Strings = _ = require("strings.js");
  types = Strings.Types;
  Chars = Strings.Chars;

  Words_ = function () {
    var Words_ = /*#__PURE__*/function () {
      function Words_() {
        _classCallCheck(this, Words_);
      }

      _createClass(Words_, null, [{
        key: "stringsFromArray",
        value: function stringsFromArray(array) {
          var i, len, ref, strings, value;
          strings = [];
          ref = _.forceArray(array);

          for (i = 0, len = ref.length; i < len; i++) {
            value = ref[i];

            if (_.isString(value)) {
              strings.push(value);
            }
          }

          return strings;
        }
      }, {
        key: "numbersFromArray",
        value: function numbersFromArray(array) {
          var i, len, numbers, ref, value;
          numbers = [];
          ref = _.forceArray(array);

          for (i = 0, len = ref.length; i < len; i++) {
            value = ref[i];

            if (_.isNumber(value)) {
              numbers.push(value + 0);
            }
          }

          return numbers;
        } // call with context!

      }, {
        key: "changeCase",
        value: function changeCase(method, args) {
          var i, index, indices, j, len, len1, pos, ref, results, results1, words;
          words = Words_.stringsFromArray(args);
          indices = Words_.numbersFromArray(args);

          if (words.length > 0) {
            var _Strings;

            this.set((_Strings = Strings)[method].apply(_Strings, [this.string].concat(_toConsumableArray(words)))); // strings
          }

          if (indices[0] === 0) {
            // words[indices] (characters)
            results = [];

            for (i = 0, len = indices.length; i < len; i++) {
              pos = indices[i];
              results.push(function () {
                var j, ref, results1;
                results1 = [];

                for (index = j = 0, ref = this.count - 1; 0 <= ref ? j <= ref : j >= ref; index = 0 <= ref ? ++j : --j) {
                  results1.push(this.words[index] = Strings[method](this.words[index], pos));
                }

                return results1;
              }.call(this));
            }

            return results;
          } else {
            if (args.length < 1) {
              // words
              indices = function () {
                var results1 = [];

                for (var j = 0, ref = this.count; 0 <= ref ? j <= ref : j >= ref; 0 <= ref ? j++ : j--) {
                  results1.push(j);
                }

                return results1;
              }.apply(this);
            }

            results1 = [];

            for (j = 0, len1 = indices.length; j < len1; j++) {
              index = indices[j];
              index = _.positiveIndex(index, this.count);
              results1.push(this.words[index] = Strings[method](this.words[index]));
            }

            return results1;
          }
        }
      }, {
        key: "applyToValidIndex",
        value: function applyToValidIndex(orgIndex, limit, callback) {
          var index;

          if (false !== (index = _.positiveIndex(orgIndex, limit))) {
            return callback(index);
          }
        }
      }]);

      return Words_;
    }();

    ;
    Words_.delimiter = ' ';
    return Words_;
  }.call(this);

  Words = /*#__PURE__*/function (_Strings2) {
    _inherits(Words, _Strings2);

    var _super = _createSuper(Words);

    function Words() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _classCallCheck(this, Words);

      _this = _super.call(this);

      _this.set.apply(_assertThisInitialized(_this), arguments);

      return _this;
    }

    _createClass(Words, [{
      key: "set",
      value: function set() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var arg, i, j, len, len1, ref, str;
        this.words = [];
        args = _.intoArray.apply(this, args);

        if (args.length < 1) {
          return this;
        }

        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          ref = Strings.split(Strings.create(arg), Words_.delimiter);

          for (j = 0, len1 = ref.length; j < len1; j++) {
            str = ref[j];
            this.words.push(str);
          }
        }

        return this;
      }
    }, {
      key: "get",
      value: function get() {
        var i, index, len, string;

        if (arguments.length < 1) {
          return this.words.join(Words_.delimiter);
        }

        string = '';

        for (i = 0, len = arguments.length; i < len; i++) {
          index = arguments[i];
          index = _.positiveIndex(index, this.count);

          if (index !== false) {
            string += this.words[index] + Words_.delimiter;
          }
        }

        return Strings.trim(string);
      }
    }, {
      key: "xs",
      value: function xs() {
        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {
          return true;
        };
        var i, index, len, ref, response, result, word;

        if (_.notFunction(callback) || this.count < 1) {
          return this;
        }

        result = [];
        ref = this.words;

        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          word = ref[index];

          if (response = callback(word, index)) {
            if (response === true) {
              result.push(word);
            } else if (_.isStringOrNumber(response)) {
              result.push(response + '');
            }
          }
        }

        this.words = result;
        return this;
      }
    }, {
      key: "find",
      value: function find(string) {
        var indices;
        indices = [];

        if ('' !== (string = _.forceString(string))) {
          this.xs(function (word, index) {
            if (word === string) {
              indices.push(index + 1);
            }

            return true;
          });
        }

        return indices;
      }
    }, {
      key: "upper",
      value: function upper() {
        Words_.changeCase.call(this, 'upper', Array.prototype.slice.call(arguments));
        return this;
      }
    }, {
      key: "lower",
      value: function lower() {
        Words_.changeCase.call(this, 'lower', Array.prototype.slice.call(arguments));
        return this;
      }
    }, {
      key: "reverse",
      value: function reverse() {
        var _this2 = this;

        var arg, i, len;

        if ((arguments != null ? arguments[0] : void 0) === 0) {
          this.xs(function (word) {
            return Strings.reverse(word);
          });
        } else if (arguments.length > 0) {
          for (i = 0, len = arguments.length; i < len; i++) {
            arg = arguments[i];
            Words_.applyToValidIndex(arg, this.count, function (index) {
              return _this2.words[index] = Strings.reverse(_this2.words[index]);
            });
          }
        } else {
          this.xs(function (word, index) {
            return _this2.get(_this2.count - index);
          });
        }

        return this;
      }
    }, {
      key: "shuffle",
      value: function shuffle(selection) {
        var _this3 = this;

        var arg, i, j, len, len1;

        if (selection != null) {
          if (_.isString(selection)) {
            for (i = 0, len = arguments.length; i < len; i++) {
              arg = arguments[i];
              this.xs(function (word, index) {
                if (word === arg) {
                  return Strings.shuffle(word);
                }

                return true;
              });
            }
          } else if (selection === 0) {
            this.xs(function (word) {
              return Strings.shuffle(word);
            });
          } else {
            for (j = 0, len1 = arguments.length; j < len1; j++) {
              arg = arguments[j];
              Words_.applyToValidIndex(arg, this.count, function (index) {
                return _this3.words[index] = Strings.shuffle(_this3.words[index]);
              });
            }
          }
        } else {
          this.words = _.shuffleArray(this.words);
        }

        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.words = [];
        return this;
      }
    }, {
      key: "remove",
      value: function remove() {
        var arg, args, i, index, j, len, len1;

        if (arguments.length < 1) {
          return this;
        }

        args = [];

        for (i = 0, len = arguments.length; i < len; i++) {
          arg = arguments[i];

          if (_.isString(arg)) {
            args.unshift(arg);
          } else if (_.isNumber(arg)) {
            args.push(Words.positiveIndex(arg, this.count));
          }
        }

        args = _.noDupAndReverse(_.insertSort(args));

        for (index = j = 0, len1 = args.length; j < len1; index = ++j) {
          arg = args[index];

          if (_.isNumber(arg)) {
            this.xs(function (word, index) {
              if (index !== arg) {
                return true;
              }
            });
          } else if (_.isString(arg)) {
            this.xs(function (word) {
              if (word !== arg) {
                return true;
              }
            });
          }
        }

        return this;
      }
    }, {
      key: "pop",
      value: function pop(amount) {
        var i, n, pop, popped, ref;
        amount = Math.abs(_.forceNumber(amount, 1));
        popped = '';

        for (n = i = 1, ref = amount; 1 <= ref ? i <= ref : i >= ref; n = 1 <= ref ? ++i : --i) {
          pop = this.words.pop();

          if (pop !== void 0) {
            popped = pop + ' ' + popped;
          }
        }

        return popped.trim();
      }
    }, {
      key: "push",
      value: function push() {
        var arg, i, len;

        for (i = 0, len = arguments.length; i < len; i++) {
          arg = arguments[i];

          if ('' !== (arg = _.forceString(arg))) {
            this.words.push(Strings.trim(arg));
          }
        }

        return this;
      }
    }, {
      key: "shift",
      value: function shift(amount) {
        var i, n, ref;
        amount = _.forceNumber(amount, 1);

        for (n = i = 1, ref = amount; 1 <= ref ? i <= ref : i >= ref; n = 1 <= ref ? ++i : --i) {
          this.words.shift();
        }

        return this;
      }
    }, {
      key: "prepend",
      value: function prepend() {
        var arg, i, len, pos;
        pos = 0;

        for (i = 0, len = arguments.length; i < len; i++) {
          arg = arguments[i];

          if ('' !== (arg = _.forceString(arg))) {
            this.words.splice(pos, 0, Strings.trim(arg));
            pos++;
          }
        }

        return this;
      }
    }, {
      key: "insert",
      value: function insert(index) {
        var i, len, pos, word;
        index = _.positiveIndex(index, this.count);
        pos = 0;

        for (var _len3 = arguments.length, words = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          words[_key3 - 1] = arguments[_key3];
        }

        for (i = 0, len = words.length; i < len; i++) {
          word = words[i];

          if ('' !== (word = _.forceString(word))) {
            this.words.splice(index + pos, 0, Strings.trim(word));
            pos++;
          }
        }

        return this;
      }
    }, {
      key: "replace",
      value: function replace(selection) {
        var _this4 = this;

        var replacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        if ('' === (replacement = Strings.trim(replacement))) {
          return this;
        }

        if (_.isNumber(selection)) {
          Words_.applyToValidIndex(selection, this.count, function (index) {
            return _this4.words.splice(index, 1, replacement);
          });
        } else {
          this.xs(function (word) {
            if (word === selection) {
              return replacement;
            }

            return true;
          });
        }

        return this;
      }
    }, {
      key: "sort",
      value: function sort() {
        _.insertSort(this.words);

        return this;
      } // refactor these two later..

    }, {
      key: "startsWith",
      value: function startsWith(start) {
        var _this5 = this;

        var result;

        if ('' === (start = _.forceString(start))) {
          return false;
        }

        result = true;
        start = new Words(start);
        start.xs(function (word, index) {
          if (word !== _this5.words[index]) {
            return result = false;
          }
        });
        return result;
      }
    }, {
      key: "endsWith",
      value: function endsWith(end) {
        var count, i, index, ref, result;

        if ('' === (end = _.forceString(end))) {
          return false;
        }

        result = true;
        count = 1;
        end = new Words(end);

        for (index = i = ref = end.count; ref <= 1 ? i <= 1 : i >= 1; index = ref <= 1 ? ++i : --i) {
          if (end.get(index) !== this.words[this.count - count++]) {
            result = false;
          }
        }

        return result;
      }
    }]);

    return Words;
  }(Strings);

  Object.defineProperty(Words.prototype, '$', {
    get: function get() {
      return this.get();
    }
  });
  Object.defineProperty(Words.prototype, 'string', {
    get: function get() {
      return this.get();
    }
  });
  Object.defineProperty(Words.prototype, 'count', {
    get: function get() {
      return this.words.length;
    }
  });
  Words.prototype.unshift = Words.prototype.prepend;
  Words.flexArgs = types.intoArray;
  Words.Strings = Strings;
  Words.types = types;
  Words.Chars = Chars;

  if (typeof define !== "undefined" && define !== null && 'function' === typeof define && define.amd) {
    define('words', [], function () {
      return Words;
    });
  } else if (typeof window !== "undefined" && window !== null) {
    window.Words = Words;
    window.types = types;
    window.Strings = Strings;
  } else if (typeof module !== "undefined" && module !== null) {
    module.exports = Words;
  }
}).call(void 0);